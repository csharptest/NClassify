#region Copyright 2010 by Roger Knapp, Licensed under the Apache License, Version 2.0
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#endregion

using System;
using System.IO;
using System.Reflection;
using CSharpTest.Net.Collections;

namespace NClassify.Generator.CodeWriters
{
    public class CsWriter : CodeWriter
    {
        public const string Global = "global::";
        private readonly Assembly _generator;
        private readonly string _generateName, _generatorVersion;
        private bool hasPreamble;

        public CsWriter(TextWriter writer) : base(writer, "{", "}")
        {
            _generator = Assembly.GetCallingAssembly();
            _generator = _generator ?? GetType().Assembly;
            _generateName = _generator.GetName().Name;
            _generatorVersion = _generator.GetName().Version.ToString(2);
        }

        public void WriteFilePreamble()
        {
            WriteLine("// Generated by {0}, Version={1}", _generateName, _generatorVersion);
            WriteLine("#pragma warning disable 1591, 0612, 3021");
            WriteLine("#region Designer generated code");
            hasPreamble = true;
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing && hasPreamble)
            {
                WriteLine("#endregion");
                hasPreamble = false;
            }

            base.Dispose(disposing);
        }

        public override string MakeString(string data)
        {
            return MakeCppString(data);
		}

        public void AddNamespaces(params string[] namespaces)
        {
            foreach (string ns in namespaces)
                WriteLine("using {0};", ns);
        }

        public override IDisposable WriteNamespace(string[] ns) 
        {
            if (ns == null || ns.Length == 0)
                return new DisposingList();//just some IDisposable... ignored.

            return WriteBlock("namespace {0}", CombineNames(".", ns));
        }

        public void WriteSummaryXml(string content, params object[] args)
        {
            if (args != null && args.Length > 0)
                content = String.Format(content, args);
            string line;
            WriteLine("/// <summary>");
            using (StringReader sr = new StringReader(content))
                while (null != (line = sr.ReadLine()))
                    WriteLine("/// {0}", System.Web.HttpUtility.HtmlEncode(line));
            WriteLine("/// </summary>");
        }

        public void WriteNonUserCode()
        {
            WriteLine("[" + Global + "System.Diagnostics.DebuggerNonUserCodeAttribute()]");
            WriteGenerated();
        }

        public void WriteGenerated()
        {
            WriteLine("[" + Global + "System.Runtime.CompilerServices.CompilerGeneratedAttribute()]");
            WriteLine("[" + Global + "System.CodeDom.Compiler.GeneratedCodeAttribute(\"{0}\", \"{1}\")]", _generateName, _generatorVersion);
        }

        public override IDisposable DeclareEnum(CodeAccess access, string name)
        {
            WriteSummaryXml("Enumerated type {0}", name);
            WriteLine("[" + Global + "System.Xml.Serialization.XmlType({0})]", MakeString(name));
            WriteGenerated();
            return WriteBlock("{0}enum {1}", access == CodeAccess.Public ? "public " : "", ToPascalCase(name));
        }
        
        public override void WriteEnumValue(string name, uint value)
        {
            WriteSummaryXml("{0} = {1}", name, value);
            WriteLine("[" + Global + "System.Xml.Serialization.XmlEnum({0})] {1} = {2},", 
                MakeString(name), ToPascalCase(name), value);
        }

        public override void DeclareStruct(CodeAccess access, string name, PropertyInfo prop)
        {
            WriteSummaryXml("Value type {0}", name);
            WriteLine("[" + Global + "System.Xml.Serialization.XmlType({0})]", MakeString(name));
            WriteNonUserCode();
            using (WriteBlock("{0}partial struct {1} : System.IEquatable<{1}>, System.IComparable<{1}>", 
                access == CodeAccess.Public ? "public " : "", 
                ToPascalCase(name)))
            {
                if (!prop.IsClsCompliant)
                    WriteLine("[global::System.CLSCompliant(false)]");
                using (WriteBlock("public {0}({1} value) : this()", ToPascalCase(name), prop.Type))
                    WriteLine("this.Value = value;");

                WriteProperty(true, prop);
                using (WriteBlock("public override string ToString()"))
                    WriteLine("return __value.ToString();");
                using (WriteBlock("public override int GetHashCode()"))
                    WriteLine("return __value.GetHashCode();");
                using (WriteBlock("public override bool Equals(object obj)"))
                    WriteLine("return obj is {0} ? Equals(({0})obj) : base.Equals(obj);", ToPascalCase(name));

                using (WriteBlock("public bool Equals({0} other)", ToPascalCase(name)))
                    WriteLine("return __value.Equals(other.__value);");
                using (WriteBlock("public int CompareTo({0} other)", ToPascalCase(name)))
                    WriteLine("return __value.CompareTo(other.__value);");

                if (!prop.IsClsCompliant)
                    WriteLine("[global::System.CLSCompliant(false)]");
                using (WriteBlock("public static explicit operator {0}({1} value)", ToPascalCase(name), prop.Type))
                {
                    WriteLine("return new {0}(value);", ToPascalCase(name));
                }
                if (!prop.IsClsCompliant)
                    WriteLine("[global::System.CLSCompliant(false)]");
                using (WriteBlock("public static explicit operator {0}({1} value)", prop.Type, ToPascalCase(name)))
                {
                    WriteLine("return value.Value;");
                }

                using (WriteBlock("public static bool operator ==({0} x, {0} y)", ToPascalCase(name)))
                    WriteLine("return x.__value.Equals(y.__value);");
                using (WriteBlock("public static bool operator !=({0} x, {0} y)", ToPascalCase(name)))
                    WriteLine("return !x.__value.Equals(y.__value);");
            }
        }

        public override void DeclareClass(CodeAccess access, string name, string[] inherits, PropertyInfo[] props)
        {
            WriteSummaryXml("Value type {0}", name);
            WriteLine("[" + Global + "System.Xml.Serialization.XmlType({0})]", MakeString(name));
            WriteNonUserCode();
            using (WriteBlock("{0}partial class {1}", access == CodeAccess.Public ? "public " : "", ToPascalCase(name)))
            {
                foreach (PropertyInfo prop in props)
                    WriteProperty(false, prop);
            }
        }

        private void WriteProperty(bool isSealed, PropertyInfo prop)
        {
            WriteLine("private bool __has_{0}{1};", ToCamelCase(prop.Name), prop.Default != null ? " = " + MakeConstant(prop.Type, prop.Default) : "");
            WriteLine("private {1} __{0};", ToCamelCase(prop.Name), prop.Type);
            if (prop.Expression != null)
                WriteLine("private static readonly " + 
                    Global + "System.Text.RegularExpressions.Regex __valid_{0} = " + "new " + 
                    Global + "System.Text.RegularExpressions.Regex({1}, (" + 
                    Global + "System.Text.RegularExpressions.RegexOptions){2});", 
                    ToCamelCase(prop.Name), MakeString(prop.Expression), (int)prop.ExpOptions);

            isSealed = isSealed || prop.Access == CodeAccess.Private;
            if (!isSealed && !prop.IsClsCompliant)
                WriteLine("[global::System.CLSCompliant(false)]");

            using (WriteBlock("{2} bool Set{0}({1} value)", ToPascalCase(prop.Name), prop.Type, isSealed ? "private" : "protected"))
            {
                if (prop.Prohibited)
                    WriteLine("return false;");
                if (!prop.IsValueType)
                    WriteLine("if (null == value) return false;");
                if (prop.MinLength.HasValue && prop.MinLength.Value > 0)
                    WriteLine("if (value.Length < {0}) return false;", prop.MinLength.Value);
                if (prop.MaxLength.HasValue && prop.MaxLength.Value < uint.MaxValue)
                    WriteLine("if (value.Length > {0}) return false;", prop.MaxLength.Value);
                if (prop.MinValue != null)
                    WriteLine("if (value < {0}) return false;", MakeConstant(prop.Type, prop.MinValue));
                if (prop.MaxValue != null)
                    WriteLine("if (value > {0}) return false;", MakeConstant(prop.Type, prop.MaxValue));
                if (prop.Expression != null)
                    WriteLine("if (__valid_{0}.IsMatch(value.ToString())) return false;", ToCamelCase(prop.Name));

                WriteLine("__{0} = value;", ToCamelCase(prop.Name));
                WriteLine("return __has_{0} = true;", ToCamelCase(prop.Name));
            }

            if(prop.Obsolete)
                WriteLine("[" + Global + "System.ObsoleteAttribute()]");

            string restrictGet = ((prop.ReadWrite & PropertyAccessors.Read) != PropertyAccessors.Read && prop.Access != CodeAccess.Private) ? "private " : "";
            string restrictSet = ((prop.ReadWrite & PropertyAccessors.Write) != PropertyAccessors.Write && prop.Access != CodeAccess.Private) ? "private " : "";
            using (WriteBlock("{0} bool Has{1}", prop.Access.ToString().ToLower(), ToPascalCase(prop.Name)))
            {
                using (WriteBlock(restrictGet + "get"))
                    WriteLine("return __has_{0};", ToCamelCase(prop.Name));

                using (WriteBlock(restrictSet + "set"))
                {
                    WriteLine("if (value) throw new System.ArgumentOutOfRangeException({0});", MakeString("Has" + ToPascalCase(prop.Name)));
                    WriteLine("__has_{0} = false;", ToCamelCase(prop.Name));
                    WriteLine("__{0} = {1};", ToCamelCase(prop.Name), MakeConstant(prop.Type, prop.Default));
                }
            }

            WriteSummaryXml("{0} {1}", prop.Type, prop.Name);
            if (prop.Obsolete)
                WriteLine("[" + Global + "System.ObsoleteAttribute()]");
            if (prop.Access != CodeAccess.Private && !prop.IsClsCompliant)
                WriteLine("[global::System.CLSCompliant(false)]");

            using (WriteBlock("{0} {1} {2}", prop.Access.ToString().ToLower(), prop.PseudoType ?? prop.Type, ToPascalCase(prop.Name)))
            {
                using (WriteBlock(restrictGet + "get"))
                {
                    WriteLine("return {1}(__{0});", ToCamelCase(prop.Name),
                        prop.PseudoType != null ? "new " + prop.PseudoType : "");
                }

                using (WriteBlock(restrictSet + "set"))
                using (WriteBlock("if (!Set{0}(value{1}))", ToPascalCase(prop.Name), prop.PseudoType != null ? ".Value" : ""))
                {
                    WriteLine("throw new System.ArgumentOutOfRangeException({0});", MakeString(ToPascalCase(prop.Name)));
                }
            }
        }

        private string MakeConstant(string type, string value)
        {
            return value != null ? value : String.Format("default({0})", type);
        }
    }
}
